<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Nightjar</title>
      <style>
         @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,400;0,700;1,400&display=swap');
         @font-face {
         font-family: "mgs1";
         src: url("./fnt/METAG___.TTF");
         }
         html,
         body {
         font-family: 'IBM Plex Sans', sans-serif;
         margin: 0;
         padding: 0;
         }
         h3 {
         cursor: pointer;
         }
         a {
         border-bottom: 1px solid red;
         font-style: italic;
         text-decoration: none;
         }
         a:visited {
         color: black;
         }
         ol li {
         margin-top: 5px;
         }
         img {
         width: 100%;
         }
         p {
         line-height: 24px;
         }
         #app {
         margin: auto;
         max-width: 800px;
         padding: 10px;
         }
         .banner {
         position: relative;
         }
         .banner .quote {
         color: white;
         font-family: "mgs1";
         font-size: 36px;
         font-style: italic;
         position: absolute;
         top: 20px;
         left: 20px;
         }
         .article .content {
         display: none;
         }
         .article .triangle {
         cursor: pointer;
         }
      </style>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
      <script>
         // hljs.highlightAll();
      </script>
   </head>
   <body>
      <div id="app">
         <div class="banner">
            <div class="quote">NIGHTJAR</div>
            <img alt="banner" />
         </div>
         <p>
            Affectionately named after the <a target="_blank" href="https://en.wikipedia.org/wiki/Nightjar">bird</a>,
            Nigthjar is a "Metal Gear-like" game. I've always enjoyed the Metal Gear
            series, and this is an attempt to create something akin to the NES/GBC/PS1 installments.
            I am making it in <a target="_blank" href="https://gamemaker.io">GameMaker</a>. There's
            not much going on in there (yet) but <a href="https://discord.gg/CpJw2TS4">join the Discord</a> if you're interested.
         </p>
         <p>
            Right now, I am just working on getting core gameplay elements in place. Once that is
            at a state I feel content with, I'll actually move on to "the game". With that,
            there is no release date for Nightjar but... it will be a while.
         </p>
         <h3>Resources</h3>
         <p>
            Below is a list of websites and tools I've used so far. Its incomplete, as when I get into
            a "Google'ing mode", in an effort to find a solution or assistance with something,
            I may forget to record it.
         </p>
         <ol>
            <li><a href="https://www.spriters-resource.com/game_boy_gbc/mggb/">The Spriter's Resource - Metal Gear: Ghost Babel</a></li>
            <li><a href="https://sfxr.me/">jsfxr - 8 bit sfx generator</a></li>
            <li><a href="https://www.youtube.com/watch?v=qTqDY4JtFfo&list=PL14Yj-e2sgzxTXIRYH-J2_PWAZRMahfLb">Peyton Burnham's YouTube on "How to Make a Top Down Shooter in GameMaker Studio 2</a></li>
            <li><a href="https://www.youtube.com/watch?v=6lgnW5sr8LU"> Creating & Changing Rooms in GameMaker 2.3 </a></li>
         </ol>
         <h3>Job postings</h3>
         <p>
            These are both paid jobs but in an effort of full transparency, there won't be "mega bucks" involved here.
            I am a solo developer, who isn't horrible at programming, and isn't a musician or artist.
         </p>
         <ul>
            <li>Pixel artist</li>
            <p>
               I am looking for a pixel artist to help me "reskin" the game, eventually. Some familiarity
               working on games, specifically GameMaker, is a bonus, but <b>no games experience is required!</b>
               If you're interested, shoot me a message on Discord (@tengille), or in the Discord. Familiarity with the Metal Gear
               series, specifically MGS (PS1) and Ghost Babel (GBC) would be nice. The sprite sheet in
               the above "Resources" section, and perhaps playing Ghost Babel a bit (<a href="https://www.retrogames.cc/gameboycolor-games/metal-gear-solid-usa.html">its free online HERE</a>),
               may be advantageous as well. Don't worry, you can use a controller.
            </p>
            <li>Chiptune artist</li>
            <p>
               I am looking for a chiptune artist to help me make a few tracks for the game, eventually. Some, but not
               all tracks would include "Main title", "Sneaking song", "Boss fight music", "Alert music", etc.
               Some familiarity working on games, is a bonus, but <b>no games experience is required!</b>
               If you're interested, shoot me a message on Discord (@tengille), or in the Discord. Familiarity with the Metal Gear
               series, specifically MGS (PS1) and Ghost Babel (GBC) would be nice. The Ghost Babel
               OST can be found <a href="https://www.youtube.com/playlist?list=PLYvFH2GxNYeaJrq8BPGjb91ddJnbanvz1">HERE</a>,
               and the MGS OST can be found <a href="https://youtu.be/fKt_-_wfSiY?t=1821">HERE</a>, as some inspiration.
            </p>
         </ul>
         <h3>Feature/Task Tracker</h3>
         <ul>
            <h4>10 Jan 2024</h4>
            <div><input type="checkbox" checked /><label>8 way movement</label></div>
            <div><input type="checkbox" checked /><label>Basic wall collision</label></div>
            <div><input type="checkbox" checked /><label>Basic player states</label></div>
            <div><input type="checkbox" checked /><label>Some very high level lore</label></div>
            <h4>17 Jan 2024</h4>
            <div><input type="checkbox" checked /><label>Setup source control [<a href="https://github.com/tengille/nightjar">repository</a>]</label></div>
            <div><input type="checkbox" checked /><label>Simple main menu</label></div>
            <div><input type="checkbox" checked /><label>Move between rooms</label></div>
            <div><input type="checkbox" checked /><label>"Crawl through" implemented</label></div>
            <div><input type="checkbox" checked /><label>"Noisy floors"</label></div>
            <div><input type="checkbox" checked /><label>More story elements complete (some of this is in my head still, need to write it down)</label></div>
            <div><input type="checkbox" checked /><label>World map rough draft / concept complete</label></div>
            <div><input type="checkbox" checked /><label>"Loading Dock" rough draft / concept complete</label></div>
            <div><input type="checkbox" checked /><label>Enemy animation based on movement direction</label></div>
            <div><input type="checkbox" checked /><label>Camera follows player</label></div>
            <h4>In progress</h4>
            <div><input type="checkbox"  /><label>Player able to "hug" wall</label></div>
            <div><input type="checkbox"  /><label>Camera shifts on wall "hug"</label></div>
            <div><input type="checkbox"  /><label>"Call" / "Radio" system</label></div>
            <h4>To do...</h4>
            <div><input type="checkbox"  /><label>Get gamepad/controller working</label></div>
            <div><input type="checkbox"  /><label>Enemy patrols (Question on pathing)</label></div>
            <div><input type="checkbox"  /><label>Enemy seeing player</label></div>
            <div><input type="checkbox"  /><label>CAUTION/ALERT mode</label></div>
            <div><input type="checkbox"  /><label>Player able to KO enemy (punches)</label></div>
            <div><input type="checkbox"  /><label>Player able to KO enem (grab)</label></div>
            <div><input type="checkbox"  /><label>Pause menu </label></div>
         </ul>
         <h3>Devlog</h3>
         <!-- 10 jan 2024 -->
         <div class="article">
            <h5 class="title"><span class="triangle">â–¸</span> 10 jan 2024</h5>
            <div class="content">
               <p>Following Burnham&#39;s YouTube video, I was able to get eight way moving up and running pretty quickly, along with some very basic collision.</p>
               <p>
                  Sprites were ripped from The Spriter&#39;s Resource, and it wasn&#39;t too bad to get them into sprite sheets and use as needed. They&#39;re still a bit <em>janky</em>, as I don&#39;t know if they&#39;re not
                  &quot;perfect&quot;, or I&#39;ve done something wrong (most likely the latter). Its not a big deal, as I will reskin the entire game eventually, when its at a good point to.
               </p>
               <p>
                  The one thing that was interesting, was the <code>state</code>
                  related to the player character. In Metal Gear games, Snake can run, crawl, and crouch. In later games (PS2 onward) he can crouch walk, and just walk, leveraging the controller&#39;s sticks.
               </p>
               <p>
                  I wanted to have a mix of Ghost Babel (GBC), and Metal Gear Solid (PS1) style movement. I abandoned &quot;rolling&quot; pretty quick, but I may come back to that, as that may be a fun thing to have for a boss fight.
                  It should look something like...
               </p>
               <img src="./img/movement.PNG" />
               <p>And in code, that looks like...</p>
               <pre><code>// create event
// states
enum PLAYER_STATE {
    STAND = <span class="hljs-number">0</span>,
    RUN = <span class="hljs-number">1</span>,
    CROUCH = <span class="hljs-number">2</span>,
    CRAWL = <span class="hljs-number">3</span>,
};

// step event
if <span class="hljs-keyword">state</span> == PLAYER_STATE.STAND {
    if _x_key { <span class="hljs-keyword">state</span> = PLAYER_STATE.CROUCH; }
    if moving { <span class="hljs-keyword">state</span> = PLAYER_STATE.RUN; }
}
else if <span class="hljs-keyword">state</span> == PLAYER_STATE.CROUCH {
    if _x_key { <span class="hljs-keyword">state</span> = PLAYER_STATE.STAND; }
    if moving { <span class="hljs-keyword">state</span> = PLAYER_STATE.CRAWL; }
  }
else if <span class="hljs-keyword">state</span> == PLAYER_STATE.RUN {
  if !moving { <span class="hljs-keyword">state</span> = PLAYER_STATE.STAND; }
  if _x_key { <span class="hljs-keyword">state</span> = PLAYER_STATE.CROUCH; }
}
else if <span class="hljs-keyword">state</span> == PLAYER_STATE.CRAWL {
  if _x_key { <span class="hljs-keyword">state</span> = PLAYER_STATE.CROUCH; }
}
</code></pre>
               <p>
                  While reasonably concise, it took a minute to get to this point. Navigating when the player could crouch and what their options were from there, the same for crawling and running (standing but not moving), was all a
                  bit interesting.
               </p>
               <p>
                  Another hurdle was navigating how to do idle sprites, facing the correct way. There is most likely a little bit of redundant code, not only in the example here, but how I&#39;m storing direction. This is in part due
                  to the way that Burnham&#39;s tutorial did movement. When the object is not moving, it defaults to a <code>sprite_pointer</code> of <code>0</code>. So, I had to make some copy code that memoizes that.
               </p>
               <pre><code>// create event
enum DIRECTION {
    <span class="hljs-attr">RIGHT</span> = <span class="hljs-number">0</span>,
    <span class="hljs-attr">UP_RIGHT</span> = <span class="hljs-number">1</span>,
    <span class="hljs-attr">UP</span> = <span class="hljs-number">2</span>,
    <span class="hljs-attr">UP_LEFT</span> = <span class="hljs-number">3</span>,
    <span class="hljs-attr">LEFT</span> = <span class="hljs-number">4</span>,
    <span class="hljs-attr">DOWN_LEFT</span> = <span class="hljs-number">5</span>,
    <span class="hljs-attr">DOWN</span> = <span class="hljs-number">6</span>,
    <span class="hljs-attr">DOWN_RIGHT</span> = <span class="hljs-number">7</span>,
}

<span class="hljs-attr">direction_state</span> = <span class="hljs-number">0</span>;

// step event
// facing direction
<span class="hljs-keyword">if</span> _right_key &amp;&amp; _up_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.UP_RIGHT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _right_key &amp;&amp; _down_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.DOWN_RIGHT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _left_key &amp;&amp; _up_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.UP_LEFT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _left_key &amp;&amp; _down_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.DOWN_LEFT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _down_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.DOWN;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _up_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.UP;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _right_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.RIGHT;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _left_key {
    <span class="hljs-attr">direction_state</span> = DIRECTION.LEFT;
}
</code></pre>
               <p>Its not the most elegant code, but it works. And then drawing the correct sprite looks like...</p>
               <pre><code>// draw event
if moving == <span class="hljs-number">0</span> {
    if <span class="hljs-keyword">state</span> == PLAYER_STATE.CROUCH {
        sprite_index = idle_crouch_sprite[direction_state];
    }
    else if <span class="hljs-keyword">state</span> == PLAYER_STATE.STAND || <span class="hljs-keyword">state</span> == PLAYER_STATE.RUN {
        sprite_index = idle_stand_sprite[direction_state];
    }
    else if <span class="hljs-keyword">state</span> == PLAYER_STATE.CRAWL {
        sprite_index = crawl_sprite[direction_state];
    }
}

if moving == <span class="hljs-number">1</span> {
    if <span class="hljs-keyword">state</span> == PLAYER_STATE.RUN {
        sprite_index = run_sprite[sprite_pointer];
    }
    else if <span class="hljs-keyword">state</span> == PLAYER_STATE.CRAWL {
        sprite_index = crawl_sprite[sprite_pointer];
    }
}
</code></pre>
               <p>Again, while all this seems straightforward... it was a fun exercise to see even a glimpse of how state works within a Metal Gear-like game. Below is a progress video:</p>
               <iframe
                  width="100%"
                  height="315"
                  src="https://www.youtube.com/embed/234c48DzAn0?si=J6Uv7A3VWUPHKDZQ"
                  title="YouTube video player"
                  frameborder="0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowfullscreen
                  ></iframe>
               <p></p>
            </div>
         </div>
         <div class="article">
            <h5 class="title"><span class="triangle">â–¸</span> 17 jan 2024</h5>
            <div class="content">
               <p>This week&#39;s update was pretty good.</p>
               <p>First, the game, and this website, is now in Github. Not a big milestone by any means, but good
                  to know that I won&#39;t lose my work, or too much of mywork.
               </p>
               <p>The game now has a simple main menu. Admittedly, it was easier to put together than I thought it
                  would be. The menu acts as a &quot;Room&quot; in game maker, has centered text, a and .gif as a sprite for the
                  background.
               </p>
               <p>The way selection is done is:</p>
               <pre><code><span class="hljs-comment">// create event</span>
menu_pointer = <span class="hljs-number">0</span>;
menu_items[<span class="hljs-number">0</span>] = <span class="hljs-string">"NEW GAME"</span>;
menu_items[<span class="hljs-number">1</span>] = <span class="hljs-string">"BRIEFING"</span>;
menu_items[<span class="hljs-number">2</span>] = <span class="hljs-string">"CREDITS"</span>;
menu_items[<span class="hljs-number">3</span>] = <span class="hljs-string">"EXIT GAME"</span>;

<span class="hljs-comment">// step event</span>
var _up_key     = keyboard_check_released(ord(<span class="hljs-string">"W"</span>));
var _down_key   = keyboard_check_released(ord(<span class="hljs-string">"S"</span>));
var _z_key      = keyboard_check_released(ord(<span class="hljs-string">"Z"</span>));

<span class="hljs-keyword">if</span> _up_key {
    menu_pointer -= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> menu_pointer &lt; <span class="hljs-number">0</span> {
        menu_pointer = array_length(menu_items) - <span class="hljs-number">1</span>;
    }
    audio_play_sound(snd_menu_select, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);
}

<span class="hljs-keyword">if</span> _down_key {
    menu_pointer += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> menu_pointer &gt; array_length(menu_items) - <span class="hljs-number">1</span> {
        menu_pointer = <span class="hljs-number">0</span>;
    }
    audio_play_sound(snd_menu_select, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);
}

<span class="hljs-keyword">if</span> _z_key {
    audio_play_sound(snd_main_menu_confirm, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">switch</span>(menu_pointer) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            room_goto(rm_test_0); <span class="hljs-comment">// first level</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            room_goto(rm_briefing);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            room_goto(rm_credits);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            game_end(0);
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
               <p>And that is literally all the code required. I don&#39;t show it in today&#39;s update video, but BRIEFING
                  and CREDITS are rooms that exist, but there&#39;s nothing in them.
               </p>
               <p>As shown, the player can now move between rooms. Again, this was easier than I thought it would be
                  and makes sense upon seeing the concept. I have an empty <code>obj_warp</code> that when the player collides with,
                  just like standard collisions, &quot;warps&quot; them to a new room at a given <code>x</code> and <code>y</code> location. There is
                  some more work to be done here perhaps on fade outs/fade ins, but the core concept is there. I&#39;ve linked
                  my resource for this above.
               </p>
               <p>Its a work in progress but part of the how radio calls will work is simlar to this, as I am currently
                  planning on &quot;warping&quot; the player to &quot;call room&quot;, that takes in an argument for a specific set of
                  text and variables. We&#39;ll see how that pans out.
               </p>
               <p>I thought about implementing footsteps as a whole, but as I am not going to have walking or crouch
                  walking in game, I didn&#39;t find it to be worthwhile. What does exist now in game is what I&#39;m calling
                  &quot;noisy floors&quot;. These can be expanded upon for various sounds in the future, and while currently guards
                  are pretty dumb, and can&#39;t see/hear anything, they will be able to in the future.
               </p>
               <p>I haven&#39;t wanted to spend too much time on story or &quot;lore&quot; as while I think, like any Metal Gear game,
                  that will be an important part, it is something that can be done later. I do have some various tidbits
                  &quot;on paper&quot;, did sort out the overall world map to limit scope, but not trying to have this be a
                  narrative exercise. Below is what a version one of what the world map looks like. Its not shown but a
                  &quot;version zero&quot; of the first level also exists, in pencil (which means its 100% subject to change).
               </p>
               <img width="400px" src="./img/map-concept.jpg" />
               <p>It is not shown in this week&#39;s video but I completed very basic pathing for patrols, and the guard
                  animates correctly based on their movement. Guards, like in Ghost Babel (ando other Metal Gear games),
                  will have various colors/sprites for their region but I need a base &quot;guard&quot; object that everything can
                  inherit from, and that is what I am working on.
               </p>
               <p>One last thing that was shown was how the camera follows the player throughout the level. If we look
                  back at last week&#39;s video we see a very small sprite, and are zoomed out quite far. One thing all
                  Metal Gear games have is a relatively zoomed in camera on the player, to not only show neat animations
                  but also have it be a challenge to spot all the enemies on the map. I looked at Ghost Babel&#39;s proportions
                  and while not exactly the same, it is a similar size (the player sprite) on the screen.
               </p>
               <p>And that&#39;s really it. Along with working on the &quot;call/radio&quot; system, I&#39;m workong on when the player
                  can &quot;hug&quot; the wall. This will move the viewport in one direction or the other, and a player will be
                  able to &quot;knock&quot; on the wall to distract a nearby guard.
               </p>
               <p>Thanks for reading.</p>
            </div>
         </div>
      </div>
      <!-- spacer -->
      <div style="height: 100px; width: 100%;"></div>
   </body>
   <script>
      // highlight JS
      hljs.highlightAll();

      // devlogs hide/show
      const articles = document.querySelectorAll(".article");
      articles.forEach((article) => {
          article.querySelector(".triangle").addEventListener("click", (e) => {
              const tri = e.target.parentElement.parentElement.querySelector(".triangle");
              const cnt = e.target.parentElement.parentElement.querySelector(".content");
              if (tri.innerHTML === "â–¾") {
                  tri.innerHTML = "â–¸";
                  cnt.style.display = "none";
              } else {
                  tri.innerHTML = "â–¾";
                  cnt.style.display = "block";
              }
          });
      });

      // dynamic banners;
      document.querySelector('.banner img').src = './img/banners/' + Math.floor(Math.random() * 7) + '.gif';
   </script>
</html>
